{% extends "base.html" %}
{% block title %}Trends — ChatGPT Statistics{% endblock %}

{% block content %}
<section class="chart-section fade-in">
  <h2>Usage Trends</h2>

  <nav style="display: flex; gap: 16px; flex-wrap: wrap; margin-bottom: 20px;">
    <div>
      <div style="font-size: 11px; color: var(--text-muted); margin-bottom: 6px; text-transform: uppercase; letter-spacing: 0.08em;">Granularity</div>
      <div class="pill-bar" id="granularity-pills"></div>
    </div>
    <div>
      <div style="font-size: 11px; color: var(--text-muted); margin-bottom: 6px; text-transform: uppercase; letter-spacing: 0.08em;">Period</div>
      <div class="pill-bar" id="year-pills"></div>
    </div>
  </nav>

  <figure class="chart-box">
    <h3>Chat Frequency</h3>
    <canvas id="chart-chats"></canvas>
  </figure>
  <figure class="chart-box">
    <h3>Average Messages per Chat</h3>
    <canvas id="chart-avg-messages"></canvas>
  </figure>
  <figure class="chart-box">
    <h3>Total Messages</h3>
    <canvas id="chart-total-messages"></canvas>
  </figure>
  <figure class="chart-box">
    <h3>Message Length Over Time</h3>
    <canvas id="chart-msg-length"></canvas>
  </figure>
  <figure class="chart-box">
    <h3>Response Ratio Over Time</h3>
    <canvas id="chart-response-ratio"></canvas>
  </figure>
  <figure class="chart-box">
    <h3>Code Block Usage Over Time</h3>
    <canvas id="chart-code-usage"></canvas>
  </figure>
</section>

<section class="chart-section fade-in">
  <h2>Top Days</h2>
  <div class="tables-grid">
    <section class="table-box" id="top-chats-table"></section>
    <section class="table-box" id="top-messages-table"></section>
  </div>
</section>
{% endblock %}

{% block scripts %}
<script>
(function() {
  const D = DASHBOARD_DATA;
  if (!D.summary) return;

  applyChartDefaults();

  // ── State ──
  let currentGranularity = 'weekly';
  let selectedYears = ['All'];
  let chartInstances = [];

  /**
   * Return the content-metrics source object for the given granularity.
   * @param {string} granularity - 'daily' | 'weekly' | 'monthly'
   * @returns {Object|undefined} Content source data or undefined if unavailable
   */
  function getContentSource(granularity) {
    if (granularity === 'daily') return D.content_charts;
    if (granularity === 'weekly') return D.content_weekly;
    return D.content_monthly;
  }

  /**
   * Extract date labels from the content source for the given granularity.
   * Monthly dates get '-01' appended so Chart.js can parse them as time values.
   * @param {string} granularity - 'daily' | 'weekly' | 'monthly'
   * @returns {string[]} Array of date strings
   */
  function getContentDates(granularity) {
    const src = getContentSource(granularity);
    if (!src) return [];
    if (granularity === 'monthly') return (src.months || []).map(function(m) { return `${m}-01`; });
    if (granularity === 'weekly') return src.weeks || [];
    return src.dates || [];
  }

  /**
   * Create a bar+line Chart.js chart on the given canvas.
   * Bar data is the primary series; lines are rolling-average overlays.
   * @param {string} canvasId - DOM id of the target canvas element
   * @param {string[]} dates - X-axis date labels
   * @param {number[]} barData - Bar series values
   * @param {string} barColor - CSS colour for the bar fill
   * @param {string} barLabel - Legend label for the bar series
   * @param {Array<{label: string, data: number[], color: string}>} lines - Rolling-average line overlays
   * @returns {Chart} The Chart.js instance
   */
  function buildChart(canvasId, dates, barData, barColor, barLabel, lines) {
    const ctx = document.getElementById(canvasId).getContext('2d');
    const labels = dates.map(function(d) { return d.indexOf('T') >= 0 ? d : `${d}T00:00:00`; });

    const datasets = [{
      type: 'bar', label: barLabel, data: barData,
      backgroundColor: barColor, borderWidth: 0,
      barPercentage: 1.0, categoryPercentage: 1.0, order: 2,
    }];

    lines.forEach(function(s) {
      datasets.push({
        type: 'line', label: s.label, data: s.data,
        borderColor: s.color, borderWidth: 2,
        pointRadius: 0, pointHoverRadius: 3, tension: 0.3, order: 1,
      });
    });

    const chart = new Chart(ctx, {
      data: { labels: labels, datasets: datasets },
      options: {
        responsive: true, maintainAspectRatio: false,
        interaction: { mode: 'index', intersect: false },
        plugins: {
          legend: { position: 'top', labels: { usePointStyle: true, pointStyle: 'circle', padding: 16, font: { size: 11 } } },
          tooltip: {
            backgroundColor: cssVar('--surface2'), borderColor: cssVar('--border'), borderWidth: 1,
            titleFont: { family: "'JetBrains Mono', monospace", size: 11 },
            bodyFont: { size: 12 }, padding: 10,
            callbacks: {
              title: function(items) { return items.length ? formatDate(items[0].label) : ''; }
            }
          },
        },
        scales: {
          x: { type: 'time', time: { unit: 'month', displayFormats: { month: 'MMM yyyy', quarter: 'MMM yyyy' } },
               grid: { display: false }, ticks: { maxRotation: 0, autoSkip: true, maxTicksLimit: 14 } },
          y: { beginAtZero: true, grid: { color: cssVar('--surface2') }, ticks: { precision: 0 } },
        },
      },
    });

    return chart;
  }

  /**
   * Create a line-only Chart.js chart on the given canvas, used for content
   * metrics (message length, response ratio, code usage).
   * @param {string} canvasId - DOM id of the target canvas element
   * @param {string[]} dates - X-axis date labels
   * @param {Array<{label: string, data: number[], color: string, dashed?: boolean, fill?: boolean, fillColor?: string}>} seriesList - Line series descriptors
   * @param {Object} [opts] - Optional chart configuration
   * @param {string} [opts.tooltipSuffix] - Suffix appended to tooltip values (e.g. ' words', '%')
   * @param {number} [opts.yMax] - Fixed maximum for the Y axis
   * @param {string} [opts.ySuffix] - Suffix appended to Y-axis tick labels
   * @returns {Chart} The Chart.js instance
   */
  function buildLineChart(canvasId, dates, seriesList, opts) {
    const ctx = document.getElementById(canvasId).getContext('2d');
    const labels = dates.map(function(d) { return d.indexOf('T') >= 0 ? d : `${d}T00:00:00`; });
    opts = opts || {};

    const datasets = buildLineDatasets(seriesList);

    const yConfig = { beginAtZero: true, grid: { color: cssVar('--surface2') } };
    if (opts.yMax) yConfig.max = opts.yMax;
    if (opts.ySuffix) {
      yConfig.ticks = { callback: function(v) { return `${v}${opts.ySuffix}`; } };
    }

    return new Chart(ctx, {
      data: { labels: labels, datasets: datasets },
      options: {
        responsive: true, maintainAspectRatio: false,
        interaction: { mode: 'index', intersect: false },
        plugins: {
          legend: { position: 'top', labels: { usePointStyle: true, pointStyle: 'circle', padding: 16, font: { size: 11 } } },
          tooltip: {
            backgroundColor: cssVar('--surface2'), borderColor: cssVar('--border'), borderWidth: 1,
            titleFont: { family: "'JetBrains Mono', monospace", size: 11 },
            bodyFont: { size: 12 }, padding: 10,
            callbacks: {
              title: function(items) { return items.length ? formatDate(items[0].label) : ''; },
              label: function(tipCtx) {
                const sfx = opts.tooltipSuffix || '';
                return `${tipCtx.dataset.label}: ${tipCtx.parsed.y.toLocaleString(undefined, {maximumFractionDigits: 1})}${sfx}`;
              }
            }
          },
        },
        scales: {
          x: { type: 'time', time: { unit: 'month', displayFormats: { month: 'MMM yyyy', quarter: 'MMM yyyy' } },
               grid: { display: false }, ticks: { maxRotation: 0, autoSkip: true, maxTicksLimit: 14 } },
          y: yConfig,
        },
      },
    });
  }

  /**
   * Render the three usage charts (chat frequency, avg messages, total messages)
   * using bar+line format with rolling-average overlays.
   * @param {Object} filtered - Year-filtered dataset with dates (string[]) and arrays (Array[])
   * @param {Object} ds - Raw dataset descriptor from getDatasets
   * @returns {number} The next unused index into filtered.arrays (for caller bookkeeping)
   */
  function renderUsageCharts(filtered, ds) {
    let idx = 0;

    const chatsValues = filtered.arrays[idx++];
    const avgMsgsValues = filtered.arrays[idx++];
    const totalMsgsValues = filtered.arrays[idx++];

    const chatsLines = ds.chats.lines.map(function(l) { return { label: l.label, data: filtered.arrays[idx++], color: l.color }; });
    const avgMsgsLines = ds.avg_messages.lines.map(function(l) { return { label: l.label, data: filtered.arrays[idx++], color: l.color }; });
    const totalMsgsLines = ds.total_messages.lines.map(function(l) { return { label: l.label, data: filtered.arrays[idx++], color: l.color }; });

    chartInstances.push(buildChart('chart-chats', filtered.dates, chatsValues, cssAlpha('--skyblue', 0.5), 'Chats', chatsLines));
    chartInstances.push(buildChart('chart-avg-messages', filtered.dates, avgMsgsValues, cssAlpha('--green', 0.5), 'Avg Messages/Chat', avgMsgsLines));
    chartInstances.push(buildChart('chart-total-messages', filtered.dates, totalMsgsValues, cssAlpha('--coral', 0.5), 'Messages', totalMsgsLines));
  }

  /**
   * Render the three content charts (message length, response ratio, code usage)
   * using line-only format with 28-day rolling averages.
   * Skipped silently when content data is unavailable.
   */
  function renderContentCharts() {
    const csrc = getContentSource(currentGranularity);
    if (!csrc) return;

    const cDates = getContentDates(currentGranularity);
    // Collect all content arrays for year filtering
    const contentArrays = [
      csrc.avg_user_words.values, csrc.avg_user_words.avg_28d,
      csrc.avg_asst_words.values, csrc.avg_asst_words.avg_28d,
      csrc.response_ratio.values, csrc.response_ratio.avg_28d,
      csrc.code_pct_user.values, csrc.code_pct_user.avg_28d,
      csrc.code_pct_asst.values, csrc.code_pct_asst.avg_28d,
    ];

    const cf = filterByYear(cDates, contentArrays, selectedYears);
    let ci = 0;
    const userWordsV = cf.arrays[ci++], userWords28 = cf.arrays[ci++];
    const asstWordsV = cf.arrays[ci++], asstWords28 = cf.arrays[ci++];
    const ratioV = cf.arrays[ci++], ratio28 = cf.arrays[ci++];
    const codePctUserV = cf.arrays[ci++], codePctUser28 = cf.arrays[ci++];
    const codePctAsstV = cf.arrays[ci++], codePctAsst28 = cf.arrays[ci++];

    // Chart 4: Message Length
    chartInstances.push(buildLineChart('chart-msg-length', cf.dates, [
      { label: 'Your avg words', data: userWordsV, color: cssVar('--skyblue') },
      { label: 'Your 28d avg', data: userWords28, color: cssVar('--skyblue'), dashed: true },
      { label: 'ChatGPT avg words', data: asstWordsV, color: cssVar('--amber') },
      { label: 'ChatGPT 28d avg', data: asstWords28, color: cssVar('--amber'), dashed: true },
    ], { tooltipSuffix: ' words' }));

    // Chart 5: Response Ratio
    chartInstances.push(buildLineChart('chart-response-ratio', cf.dates, [
      { label: 'Response ratio', data: ratioV, color: cssVar('--purple'), fill: true, fillColor: cssAlpha('--purple', 0.12) },
      { label: '28d avg', data: ratio28, color: cssVar('--purple'), dashed: true },
    ], { tooltipSuffix: 'x' }));

    // Chart 6: Code Block Usage
    chartInstances.push(buildLineChart('chart-code-usage', cf.dates, [
      { label: '% your msgs with code', data: codePctUserV, color: cssVar('--skyblue') },
      { label: 'Your 28d avg', data: codePctUser28, color: cssVar('--skyblue'), dashed: true },
      { label: '% ChatGPT msgs with code', data: codePctAsstV, color: cssVar('--coral') },
      { label: 'ChatGPT 28d avg', data: codePctAsst28, color: cssVar('--coral'), dashed: true },
    ], { tooltipSuffix: '%', yMax: 100 }));
  }

  /**
   * Render (or re-render) all six trend charts. Destroys any existing chart
   * instances first, then delegates to renderUsageCharts and renderContentCharts.
   */
  function renderCharts() {
    // Destroy existing
    chartInstances.forEach(function(c) { c.destroy(); });
    chartInstances = [];

    const ds = getDatasets(D, currentGranularity);

    // Build arrays for year filtering
    const allArrays = [
      ds.chats.values,
      ds.avg_messages.values,
      ds.total_messages.values,
    ];
    // Also include line data
    ds.chats.lines.forEach(function(l) { allArrays.push(l.data); });
    ds.avg_messages.lines.forEach(function(l) { allArrays.push(l.data); });
    ds.total_messages.lines.forEach(function(l) { allArrays.push(l.data); });

    const filtered = filterByYear(ds.dates, allArrays, selectedYears);

    renderUsageCharts(filtered, ds);
    renderContentCharts();
  }

  createSinglePills('granularity-pills', ['Daily', 'Weekly', 'Monthly'], 'Weekly', function(val) {
    currentGranularity = val.toLowerCase();
    renderCharts();
  });

  const years = ['All'];
  if (D.charts && D.charts.dates) {
    const yearSet = {};
    D.charts.dates.forEach(function(d) { yearSet[d.substring(0, 4)] = true; });
    Object.keys(yearSet).sort().forEach(function(y) { years.push(y); });
  }

  createMultiPills('year-pills', years, function(selected) {
    selectedYears = selected;
    renderCharts();
    renderTopTables();
  });

  // Initial render
  renderCharts();

  // ── Top Days Tables ──
  const TOP_DAYS_LIMIT = 10;

  /**
   * Filter table rows to only those whose date field matches a selected year.
   * Returns all rows when 'All' is selected or the year list is empty.
   * @param {Object[]} rows - Table data rows
   * @param {string[]} years - Selected year strings or ['All']
   * @param {string} dateKey - Property name containing the date string
   * @returns {Object[]} Filtered rows
   */
  function filterTableByYear(rows, years, dateKey) {
    if (years.indexOf('All') >= 0 || years.length === 0) return rows;
    return rows.filter(function(r) { return years.indexOf(r[dateKey].substring(0, 4)) >= 0; });
  }

  /**
   * Render a ranked "top days" table into the given container element.
   * Clears existing content, builds a table header, and populates rows
   * filtered by the currently selected years.
   * @param {string} containerId - DOM id of the table container
   * @param {string} title - Heading text above the table
   * @param {Object[]} rows - Source data rows (pre-sorted by rank)
   * @param {string} valueKey - Property name for the numeric value column
   * @param {string} valueLabel - Header text for the value column
   */
  function renderTopTable(containerId, title, rows, valueKey, valueLabel) {
    const container = document.getElementById(containerId);
    clearChildren(container);
    container.appendChild(txt('h3', title));

    const table = document.createElement('table');
    const thead = document.createElement('thead');
    const headerRow = document.createElement('tr');
    headerRow.appendChild(txt('th', '#'));
    headerRow.appendChild(txt('th', 'Date'));
    headerRow.appendChild(txt('th', valueLabel, 'num-col'));
    thead.appendChild(headerRow);
    table.appendChild(thead);

    const tbody = document.createElement('tbody');
    const filtered = filterTableByYear(rows, selectedYears, 'date').slice(0, TOP_DAYS_LIMIT);
    filtered.forEach(function(r, i) {
      const tr = document.createElement('tr');
      tr.appendChild(txt('td', String(i + 1), 'rank'));
      tr.appendChild(txt('td', r.date, 'date'));
      tr.appendChild(txt('td', r[valueKey].toLocaleString(), 'num'));
      tbody.appendChild(tr);
    });
    table.appendChild(tbody);
    container.appendChild(table);
  }

  /**
   * Render both "top days" tables (by chats and by messages).
   * Skips each table if its source data is empty or missing.
   */
  function renderTopTables() {
    const s = D.summary;
    if (s.top_days_by_chats && s.top_days_by_chats.length) {
      renderTopTable('top-chats-table', 'Top Days by Chats', s.top_days_by_chats, 'total_chats', 'Chats');
    }
    if (s.top_days_by_messages && s.top_days_by_messages.length) {
      renderTopTable('top-messages-table', 'Top Days by Messages', s.top_days_by_messages, 'total_messages', 'Messages');
    }
  }

  renderTopTables();

})();
</script>
{% endblock %}
