{% extends "base.html" %}
{% block title %}Patterns — ChatGPT Statistics{% endblock %}

{% block content %}
<style>
.heatmap-wrap { overflow-x: auto; margin-bottom: 8px; }
.heatmap {
  display: grid;
  grid-template-columns: 40px repeat(24, 1fr);
  gap: 2px;
  min-width: 500px;
}
.heatmap-label {
  font-family: 'JetBrains Mono', monospace;
  font-size: 10px;
  color: var(--text-dim);
  display: flex;
  align-items: center;
  justify-content: center;
}
.heatmap-cell {
  aspect-ratio: 1;
  border-radius: 3px;
  min-width: 14px;
  min-height: 14px;
  position: relative;
  cursor: default;
}
.heatmap-cell:hover { outline: 1px solid var(--amber); outline-offset: -1px; }
.heatmap-hour-labels {
  display: grid;
  grid-template-columns: 40px repeat(24, 1fr);
  gap: 2px;
  min-width: 500px;
}
.heatmap-hour-label {
  font-family: 'JetBrains Mono', monospace;
  font-size: 9px;
  color: var(--text-muted);
  text-align: center;
}
.heatmap-tooltip {
  position: fixed;
  background: var(--surface2);
  border: 1px solid var(--border);
  border-radius: 6px;
  padding: 6px 10px;
  font-family: 'JetBrains Mono', monospace;
  font-size: 11px;
  color: var(--text);
  pointer-events: none;
  z-index: 100;
  white-space: nowrap;
  display: none;
}
.weekday-stats {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 16px;
}
@media (max-width: 640px) { .weekday-stats { grid-template-columns: 1fr; } }
.weekday-stat-card {
  background: var(--surface);
  border: 1px solid var(--border);
  border-radius: 10px;
  padding: 24px;
  text-align: center;
}
.weekday-stat-card h3 {
  font-size: 13px;
  font-weight: 500;
  text-transform: uppercase;
  letter-spacing: 0.08em;
  color: var(--text-dim);
  margin-bottom: 12px;
}
.weekday-stat-big {
  font-family: 'JetBrains Mono', monospace;
  font-size: 32px;
  font-weight: 700;
  letter-spacing: -0.5px;
  margin-bottom: 4px;
}
.weekday-stat-sub {
  font-size: 12px;
  color: var(--text-dim);
  margin-bottom: 8px;
}
.weekday-bar-row {
  display: flex;
  align-items: center;
  gap: 8px;
  margin-top: 4px;
  padding: 4px 0;
}
.weekday-bar-label {
  font-family: 'JetBrains Mono', monospace;
  font-size: 11px;
  color: var(--text-dim);
  width: 30px;
  text-align: right;
}
.weekday-bar-track {
  flex: 1;
  height: 8px;
  background: var(--surface2);
  border-radius: 4px;
  overflow: hidden;
}
.weekday-bar-fill {
  height: 100%;
  border-radius: 4px;
  transition: width 0.4s ease;
}
.weekday-bar-value {
  font-family: 'JetBrains Mono', monospace;
  font-size: 11px;
  color: var(--text);
  width: 45px;
  text-align: right;
}
</style>

<section class="chart-section fade-in">
  <h2>Activity Heatmap</h2>
  <div class="chart-box">
    <h3>Messages by Day & Hour</h3>
    <div class="heatmap-wrap" id="heatmap-container"></div>
  </div>
</section>

<section class="chart-section fade-in">
  <h2>Hourly Distribution</h2>
  <div class="chart-box">
    <h3>Messages by Hour of Day</h3>
    <canvas id="chart-hourly" style="max-height: 300px;"></canvas>
  </div>
</section>

<section class="chart-section fade-in">
  <h2>Weekly Rhythm</h2>
  <div class="weekday-stats" id="weekday-comparison"></div>
</section>

<section class="chart-section fade-in">
  <h2>Code Analysis</h2>
  <div class="chart-box">
    <div id="code-stat-line" style="font-size: 13px; color: var(--text-dim); margin-bottom: 12px;"></div>
    <h3>Top Languages</h3>
    <canvas id="chart-code-languages" style="max-height: 340px;"></canvas>
  </div>
</section>

<section class="chart-section fade-in">
  <h2>Activity Overview</h2>
  <div class="table-box" id="activity-table"></div>
</section>

<section class="chart-section gap-table-wrap fade-in">
  <h2>Gap Analysis</h2>
  <div class="table-box" id="gaps-table"></div>
</section>

<div class="heatmap-tooltip" id="heatmap-tooltip"></div>
{% endblock %}

{% block scripts %}
<script>
(function() {
  const D = DASHBOARD_DATA;
  if (!D.hourly) return;

  const DAYS = ['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun'];
  const FULL_DAYS = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday'];
  const HOUR_LABELS = [0, 3, 6, 9, 12, 15, 18, 21];

  /**
   * Return a CSS colour string for a heatmap cell based on its value.
   * @param {number} val   - Message count for the cell.
   * @param {number} maxVal - Maximum count across all cells (used for ratio).
   * @returns {string} CSS colour value.
   */
  function cellColor(val, maxVal) {
    if (val === 0 || maxVal === 0) return 'var(--surface2)';
    const ratio = val / maxVal;
    if (ratio < 0.25) return 'rgba(229, 165, 75, 0.2)';
    if (ratio < 0.50) return 'rgba(229, 165, 75, 0.5)';
    if (ratio < 0.75) return 'rgba(229, 165, 75, 0.8)';
    return 'var(--amber)';
  }

  /**
   * Build the 7x24 activity heatmap grid with hour labels, tooltip
   * interactions, and ARIA attributes for accessibility.
   * Reads from D.hourly.heatmap (7 arrays of 24 integers).
   */
  function buildHeatmap() {
    const heatmap = D.hourly.heatmap;
    if (!heatmap || heatmap.length !== 7) return;

    const container = document.getElementById('heatmap-container');
    const tooltip = document.getElementById('heatmap-tooltip');

    // Find max value for intensity scaling
    let maxVal = 0;
    for (let d = 0; d < 7; d++) {
      for (let h = 0; h < 24; h++) {
        if (heatmap[d][h] > maxVal) maxVal = heatmap[d][h];
      }
    }

    // Hour labels row
    const hourRow = el('div', { className: 'heatmap-hour-labels' });
    hourRow.appendChild(el('div')); // empty spacer for row label column
    for (let h = 0; h < 24; h++) {
      const lbl = el('div', { className: 'heatmap-hour-label' });
      if (HOUR_LABELS.indexOf(h) >= 0) lbl.textContent = String(h);
      hourRow.appendChild(lbl);
    }
    container.appendChild(hourRow);

    // Grid rows
    const grid = el('div', { className: 'heatmap' });
    grid.setAttribute('role', 'grid');
    grid.setAttribute('aria-label', 'Activity heatmap showing messages by day and hour');
    for (let d = 0; d < 7; d++) {
      // Row label
      const rowLabel = el('div', { className: 'heatmap-label', textContent: DAYS[d] });
      rowLabel.setAttribute('role', 'row');
      grid.appendChild(rowLabel);
      // Cells
      for (let h = 0; h < 24; h++) {
        const val = heatmap[d][h];
        const cell = el('div', { className: 'heatmap-cell' });
        cell.style.backgroundColor = cellColor(val, maxVal);
        cell.setAttribute('data-day', DAYS[d]);
        cell.setAttribute('data-hour', String(h));
        cell.setAttribute('data-count', String(val));
        cell.setAttribute('role', 'gridcell');
        const hourStr = `${h < 10 ? '0' : ''}${h}:00`;
        cell.setAttribute('aria-label', `${FULL_DAYS[d]} ${hourStr} \u2014 ${val} messages`);
        grid.appendChild(cell);
      }
    }
    container.appendChild(grid);

    // Tooltip on hover
    grid.addEventListener('mouseover', function(e) {
      const cell = e.target;
      if (!cell.classList.contains('heatmap-cell')) return;
      const day = cell.getAttribute('data-day');
      const hour = cell.getAttribute('data-hour');
      const count = cell.getAttribute('data-count');
      const hourNum = parseInt(hour, 10);
      const label = `${hourNum < 10 ? '0' : ''}${hourNum}:00`;
      tooltip.textContent = `${day} ${label} \u2014 ${parseInt(count, 10).toLocaleString()} msgs`;
      tooltip.style.display = 'block';
    });
    grid.addEventListener('mousemove', function(e) {
      tooltip.style.left = `${e.clientX + 12}px`;
      tooltip.style.top = `${e.clientY - 30}px`;
    });
    grid.addEventListener('mouseout', function(e) {
      if (!e.target.classList.contains('heatmap-cell')) return;
      tooltip.style.display = 'none';
    });
  }

  /**
   * Build the weekday-vs-weekend comparison cards showing totals,
   * averages, per-day bar charts, and the weekday/weekend ratio.
   * Reads from D.hourly.weekday_totals (array of 7 integers, Mon-Sun).
   */
  function buildWeekdayCards() {
    const weekdayTotals = D.hourly.weekday_totals;
    if (!weekdayTotals || weekdayTotals.length !== 7) return;

    const compContainer = document.getElementById('weekday-comparison');

    let weekdaySum = 0;
    let weekendSum = 0;
    let maxDay = 0;
    for (let i = 0; i < 7; i++) {
      if (i < 5) weekdaySum += weekdayTotals[i];
      else weekendSum += weekdayTotals[i];
      if (weekdayTotals[i] > maxDay) maxDay = weekdayTotals[i];
    }
    const totalAll = weekdaySum + weekendSum;
    const weekdayAvg = Math.round(weekdaySum / 5);
    const weekendAvg = Math.round(weekendSum / 2);
    const ratio = weekendAvg > 0 ? (weekdayAvg / weekendAvg).toFixed(2) : '\u2014';

    /**
     * Create a stat card with header, big number, subtitle lines, and
     * per-day bar rows for the given day range.
     * @param {string} title    - Card heading text.
     * @param {number} sum      - Total messages for the group.
     * @param {number} avg      - Average messages per day.
     * @param {number} startIdx - First index in weekdayTotals (inclusive).
     * @param {number} endIdx   - Last index in weekdayTotals (exclusive).
     * @param {string} colour   - CSS variable for the accent colour.
     * @returns {HTMLElement} The complete card element.
     */
    function createCard(title, sum, avg, startIdx, endIdx, colour) {
      const card = el('div', { className: 'weekday-stat-card' });
      card.appendChild(txt('h3', title));
      const big = txt('div', sum.toLocaleString(), 'weekday-stat-big');
      big.style.color = `var(--${colour})`;
      card.appendChild(big);
      card.appendChild(txt('div', `total messages \u00b7 ${avg.toLocaleString()}/day avg`, 'weekday-stat-sub'));
      card.appendChild(txt('div', `${Math.round(sum / totalAll * 100)}% of all messages`, 'weekday-stat-sub'));

      for (let i = startIdx; i < endIdx; i++) {
        const row = el('div', { className: 'weekday-bar-row' });
        row.appendChild(txt('span', DAYS[i], 'weekday-bar-label'));
        const track = el('div', { className: 'weekday-bar-track' });
        const fill = el('div', { className: 'weekday-bar-fill' });
        fill.style.width = `${maxDay > 0 ? (weekdayTotals[i] / maxDay * 100) : 0}%`;
        fill.style.background = `var(--${colour})`;
        track.appendChild(fill);
        row.appendChild(track);
        row.appendChild(txt('span', weekdayTotals[i].toLocaleString(), 'weekday-bar-value'));
        card.appendChild(row);
      }
      return card;
    }

    compContainer.appendChild(createCard('Weekdays (Mon\u2013Fri)', weekdaySum, weekdayAvg, 0, 5, 'skyblue'));

    const weCard = createCard('Weekends (Sat\u2013Sun)', weekendSum, weekendAvg, 5, 7, 'amber');
    const ratioNote = txt('div', `Weekday/weekend ratio: ${ratio}x`, 'weekday-stat-sub');
    ratioNote.style.marginTop = '12px';
    weCard.appendChild(ratioNote);
    compContainer.appendChild(weCard);
  }

  /**
   * Build the hourly distribution horizontal bar chart.
   * Reads from D.hourly.hourly_totals (array of 24 integers).
   */
  function buildHourlyChart() {
    const hourlyTotals = D.hourly.hourly_totals;
    if (!hourlyTotals || hourlyTotals.length !== 24) return;

    const labels = [];
    for (let i = 0; i < 24; i++) labels.push(`${i}:00`);

    const ctx = document.getElementById('chart-hourly').getContext('2d');
    new Chart(ctx, {
      type: 'bar',
      data: {
        labels: labels,
        datasets: [{
          label: 'Messages',
          data: hourlyTotals,
          backgroundColor: 'rgba(108, 180, 217, 0.7)',
          borderWidth: 0,
          barPercentage: 0.85,
          categoryPercentage: 0.9,
        }],
      },
      options: {
        indexAxis: 'y',
        responsive: true,
        maintainAspectRatio: false,
        plugins: {
          legend: { display: false },
          tooltip: {
            backgroundColor: '#1e2029',
            borderColor: '#2a2d3a',
            borderWidth: 1,
            bodyFont: { size: 12 },
            padding: 10,
            callbacks: {
              label: function(c) { return `${c.parsed.x.toLocaleString()} messages`; }
            },
          },
        },
        scales: {
          x: { beginAtZero: true, grid: { color: '#1e2029' }, ticks: { precision: 0 } },
          y: { grid: { display: false }, ticks: { font: { family: "'JetBrains Mono', monospace", size: 10 } } },
        },
      },
    });
  }

  /**
   * Build the code languages horizontal bar chart and summary line.
   * Reads from D.code_stats (object with language_counts array).
   */
  function buildCodeLanguagesChart() {
    const codeStats = D.code_stats;
    if (codeStats && codeStats.language_counts && codeStats.language_counts.length) {
      const statLine = document.getElementById('code-stat-line');
      statLine.textContent = `${codeStats.pct_with_code}% of conversations include code blocks (${codeStats.total_conversations_with_code.toLocaleString()} conversations)`;

      const top10 = codeStats.language_counts.slice(0, 10);
      const langLabels = top10.map(function(l) { return l.language; });
      const langCounts = top10.map(function(l) { return l.count; });

      const langCtx = document.getElementById('chart-code-languages').getContext('2d');
      new Chart(langCtx, {
        type: 'bar',
        data: {
          labels: langLabels,
          datasets: [{
            label: 'Conversations',
            data: langCounts,
            backgroundColor: 'rgba(229,165,75,0.7)',
            borderWidth: 0,
            barPercentage: 0.7,
            categoryPercentage: 0.85,
          }],
        },
        options: {
          indexAxis: 'y',
          responsive: true,
          maintainAspectRatio: false,
          plugins: {
            legend: { display: false },
            tooltip: {
              backgroundColor: '#1e2029', borderColor: '#2a2d3a', borderWidth: 1,
              bodyFont: { size: 12 }, padding: 10,
              callbacks: {
                label: function(c) { return `${c.parsed.x.toLocaleString()} conversations`; }
              },
            },
          },
          scales: {
            x: { beginAtZero: true, grid: { color: '#1e2029' }, ticks: { precision: 0 } },
            y: { grid: { display: false }, ticks: { font: { family: "'JetBrains Mono', monospace", size: 11 } } },
          },
        },
      });
    } else {
      const statLine = document.getElementById('code-stat-line');
      if (statLine) statLine.textContent = 'No code blocks detected in conversations.';
    }
  }

  /**
   * Build the activity-by-year overview table.
   * Reads from D.activity_by_year (array of year summary objects).
   */
  function buildActivityTable() {
    const activityData = D.activity_by_year;
    if (!activityData || !activityData.length) return;

    const actEl = document.getElementById('activity-table');
    const tbl = document.createElement('table');
    const th = document.createElement('thead');
    const hr = document.createElement('tr');
    ['Year', 'Total Days', 'Active', '% Active', 'Inactive', '% Inactive'].forEach(function(h) {
      const cell = txt('th', h);
      if (h !== 'Year') cell.className = 'num-col';
      hr.appendChild(cell);
    });
    th.appendChild(hr);
    tbl.appendChild(th);

    const tb = document.createElement('tbody');
    activityData.forEach(function(row) {
      const tr = document.createElement('tr');
      const isOverall = row.year === 'Overall';
      if (isOverall) tr.style.fontWeight = '700';

      const yearTd = txt('td', row.year);
      if (isOverall) yearTd.style.color = 'var(--amber)';
      tr.appendChild(yearTd);
      tr.appendChild(txt('td', row.total_days.toLocaleString(), 'num'));
      tr.appendChild(txt('td', row.days_active.toLocaleString(), 'num'));
      tr.appendChild(txt('td', `${row.pct_active.toFixed(1)}%`, 'num'));
      tr.appendChild(txt('td', row.days_inactive.toLocaleString(), 'num'));
      tr.appendChild(txt('td', `${row.pct_inactive.toFixed(1)}%`, 'num'));
      tb.appendChild(tr);
    });
    tbl.appendChild(tb);
    actEl.appendChild(tbl);
  }

  /**
   * Build the gap analysis table with year-filter pill bar and
   * re-renderable rows. Reads from D.gaps and D.gap_stats.
   */
  function buildGapTable() {
    const gs = D.gap_stats || {};
    const gapsEl = document.getElementById('gaps-table');
    const TOP_GAPS_LIMIT = 20;
    let selectedGapYears = ['All'];

    if (!D.gaps || !D.gaps.length) return;

    const titleEl = txt('h3', 'Longest Gaps');
    if (gs.proportion_inactive) {
      const pctSpan = document.createElement('span');
      pctSpan.textContent = ` (${gs.proportion_inactive.toFixed(1)}% of days inactive)`;
      pctSpan.style.fontWeight = '400';
      pctSpan.style.color = 'var(--text-dim)';
      pctSpan.style.fontSize = '12px';
      titleEl.appendChild(pctSpan);
    }
    gapsEl.appendChild(titleEl);

    // Auto-detect years from gap data
    const gapYearSet = {};
    D.gaps.forEach(function(g) { gapYearSet[g.start_timestamp.substring(0, 4)] = true; });
    const gapYears = ['All'];
    Object.keys(gapYearSet).sort().forEach(function(y) { gapYears.push(y); });

    // Pill bar (multi-select)
    const pillBar = el('div', { className: 'pill-bar' });
    let allGapPill = null;

    /**
     * Collect text content of all active year pills (excluding "All").
     * @returns {string[]} Array of active year strings.
     */
    function getSelectedGapYears() {
      const selected = [];
      pillBar.querySelectorAll('.pill').forEach(function(p) {
        if (p.classList.contains('active') && p.textContent !== 'All') {
          selected.push(p.textContent);
        }
      });
      return selected;
    }

    /**
     * Synchronise the "All" pill state: activate it when every year
     * pill is active or none are; deactivate it otherwise.
     */
    function syncGapAllPill() {
      const yearPills = pillBar.querySelectorAll('.pill:not([data-all])');
      let allActive = true;
      yearPills.forEach(function(p) { if (!p.classList.contains('active')) allActive = false; });
      if (allActive || getSelectedGapYears().length === 0) {
        allGapPill.classList.add('active');
        yearPills.forEach(function(p) { p.classList.add('active'); });
      } else {
        allGapPill.classList.remove('active');
      }
    }

    gapYears.forEach(function(yr) {
      const pill = txt('button', yr, 'pill active');
      pill.type = 'button';
      if (yr === 'All') {
        pill.setAttribute('data-all', 'true');
        allGapPill = pill;
        pill.addEventListener('click', function() {
          pillBar.querySelectorAll('.pill').forEach(function(p) { p.classList.add('active'); });
          selectedGapYears = ['All'];
          renderGapRows();
        });
      } else {
        pill.addEventListener('click', function() {
          pill.classList.toggle('active');
          const selected = getSelectedGapYears();
          if (selected.length === 0) {
            allGapPill.classList.add('active');
            pillBar.querySelectorAll('.pill:not([data-all])').forEach(function(p) { p.classList.add('active'); });
            selectedGapYears = ['All'];
          } else {
            syncGapAllPill();
            selectedGapYears = selected;
          }
          renderGapRows();
        });
      }
      pillBar.appendChild(pill);
    });
    gapsEl.appendChild(pillBar);

    const table = document.createElement('table');
    const thead = document.createElement('thead');
    const headerRow = document.createElement('tr');
    headerRow.appendChild(txt('th', '#'));
    headerRow.appendChild(txt('th', 'Start'));
    headerRow.appendChild(txt('th', 'End'));
    headerRow.appendChild(txt('th', 'Days', 'num-col'));
    thead.appendChild(headerRow);
    table.appendChild(thead);

    const gapTbody = document.createElement('tbody');
    table.appendChild(gapTbody);
    gapsEl.appendChild(table);

    /**
     * Filter gap entries to only those whose start year is in the
     * selected set. Returns all gaps when "All" is selected.
     * @param {Object[]} gaps  - Full array of gap objects.
     * @param {string[]} years - Selected year strings (or ['All']).
     * @returns {Object[]} Filtered gap array.
     */
    function filterGapsByYear(gaps, years) {
      if (years.indexOf('All') >= 0 || years.length === 0) return gaps;
      return gaps.filter(function(g) {
        return years.indexOf(g.start_timestamp.substring(0, 4)) >= 0;
      });
    }

    /**
     * Clear and re-render the gap table body based on the current
     * year filter selection, limited to TOP_GAPS_LIMIT rows.
     */
    function renderGapRows() {
      clearChildren(gapTbody);
      const filtered = filterGapsByYear(D.gaps, selectedGapYears).slice(0, TOP_GAPS_LIMIT);
      filtered.forEach(function(g, i) {
        const tr = document.createElement('tr');
        tr.appendChild(txt('td', String(i + 1), 'rank'));
        tr.appendChild(txt('td', formatDate(g.start_timestamp), 'date'));
        tr.appendChild(txt('td', formatDate(g.end_timestamp)));
        tr.appendChild(txt('td', g.length_days.toFixed(1), 'num'));
        gapTbody.appendChild(tr);
      });
    }

    renderGapRows();
  }

  // ── 1. Activity Heatmap ──
  buildHeatmap();

  // ── 2. Hourly Bar Chart ──
  applyChartDefaults();
  buildHourlyChart();

  // ── 3. Weekday vs Weekend ──
  buildWeekdayCards();

  // ── 4. Code Languages Chart ──
  buildCodeLanguagesChart();

  // ── 5. Activity Overview Table ──
  buildActivityTable();

  // ── 6. Gap Analysis Table ──
  buildGapTable();

})();
</script>
{% endblock %}
